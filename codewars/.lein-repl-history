(pow 1 2)
(power 1 2)
(repeat 1 2)
(repeat 2 2)
(repeat 2 4)
(repeat 4 4)
(apply * (repeat 4 4))
(apply * (repeat 2 2))
(apply * (repeat 2 3))
(range 1 2)
(range 1 3)
(int \1)
(int \0
)
(str 123)
(map #(- (int %) \0) (str 123))
(map #(- (int %) (int \0)) (str 123))
(map #(- (int %) (int \0)) (str 1234))
(doc iterate)
(take 5 (iterate 1 inc))
(take 5 (iterate inc 1))
(Math/pow 1 2)
(reduce * 2 2)
(zip [1 2 3] [\a \b])
(zipmap [1 2 3] [\a \b])
(map {\I 1, \O 2} "IO")
(map {\I 1, \O 2} "OI")
(doc split)
(require '[clojure.string :as str])
(str/split "abc efg" " ")
(str/split "abc efg" #" ")
(first (str/split "abc efg" #" "))
(second (str/split "abc efg" #" "))
(list \a \b)
(vec \a \b)
(vector \a \b)
ls
(len [1 2])
(size [1 2])
(count [1 2])
(doc map-indexed)
map-indexed vec [\a \b]
(map-indexed vec [\a \b])
(doc identity)
(map-indexed identity [\a \b])
(map-indexed vector [\a \b])
(last [1 2 3])
(doc conj)
(conj [1 2] 3)
(and true 1)
(and true false 1)
(doc println)
(println 1 2)
(update {} :1 2)
(assoc {} :1 2)
(assoc (assoc {} :1 2) :1 3)
(mod 4 2)
(zero? (mod 4 2))
(range 2 (quot 4 2))
(doc range)
(quot 4 2)
(doc max)
(doc maximum)
(apply max [1 2 3])
(apply + [])
(abs -1)
(- 1)
(and (> 0 -1) -1)
exit
(max 1 2)
(cons 1 [])
(doc lazy-seq)
(doc set)
(take 3 [1 2 3 4])
(cons 1 2)
(cons 1 [])
(conj 1 2)
(cons 1 2 [])
(doc sequence)
(doc repeat)
(doc iterate)
(doc concat)
(concat [1] [2])
(concat [[1] [2]])
(apply concat [[1] [2]])
(doc repeat)
(doc iterate)
(take 5 (iterate + 1))
(take 5 (iterate inc 1))
(conj #{} 1)
(conj #{} 1 2)
(conj #{} 1 2 3)
(apply conj #{} [1 2 3])
(count #{1 2})
(sort #{1 3 2})
(doc identity)
(map-indexed vector [1 2 3])
(Math/pow 1 2)
(Math/pow 2 10)
(Math/pow 2 4)
(Math/pow 2 8)
(Math/pow 2 5)
(Math/pow 2 6)
:q
(exit)
help
(help)
(doc reduce)
(exit)
count {:a 1 :b 2} 
(keys {:a 1 :b 2})
(count {:a 1 :b 2})
(vec {:a 1 :b 2})
(key {:a 1 :b 2})
(keys {:a 1 :b 2})
(min 1 2)
(min 1 2 3)
:q
(exit)
(concat [[1 2]]
)
(concat [[1 2] [2 3])
(concat [[1 2] [2 3]])
(apply concat [[1 2] [2 3]])
(nth [1 2 3] 0)
(nth [1 2 3] 1)
(sorted-map 1 1)
(into (sorted-map 1 1) 2 1)
(assoc (sorted-map 1 1) 2 1)
(keys (assoc (sorted-map 1 1) 2 1))
(keys (assoc (sorted-map 2 1) 1 1))
(assoc (sorted-map 2 1) 1 1)
(hash-map 1 1)
(assoc (hash-map 3 1) 1 1)
(assoc (assoc (hash-map 3 1) 1 1) 2 1)
(keys (assoc (assoc (hash-map 3 1) 1 1) 2 1))
:q
(exit)
